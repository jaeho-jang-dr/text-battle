// Server-side only battle operations
// This file should only be imported in API routes

import { memoryStore, Character, Battle } from "./db/memory-store";
import { getCharacterById, updateCharacter } from "./character-server";

const characters = memoryStore.characters;
const battles = memoryStore.battles;

// Battle restriction tracking
const battleRestrictions = new Map<string, { lastBattleTime: Date; dailyBattleCount: number }>();

// ELO rating calculation constants
const DEFAULT_ELO = 1000;
const K_FACTOR_NEW_PLAYER = 32;  // For players with < 30 games
const K_FACTOR_EXPERIENCED = 16;  // For experienced players
const NEW_PLAYER_GAME_THRESHOLD = 30;

// Battle scoring constants
const BASE_SCORE = 100;
const ELO_MULTIPLIER = 0.1;

// Battle restrictions
const DAILY_BATTLE_LIMIT = 20;
const BATTLE_COOLDOWN_MS = 1 * 1000; // 1 second

// Calculate K-factor based on games played
function getKFactor(gamesPlayed: number): number {
  return gamesPlayed < NEW_PLAYER_GAME_THRESHOLD ? K_FACTOR_NEW_PLAYER : K_FACTOR_EXPERIENCED;
}

// Calculate expected outcome for ELO
function getExpectedOutcome(playerElo: number, opponentElo: number): number {
  return 1 / (1 + Math.pow(10, (opponentElo - playerElo) / 400));
}

// Calculate ELO change
function calculateEloChange(
  playerElo: number,
  opponentElo: number,
  didWin: boolean,
  playerGamesPlayed: number
): number {
  const kFactor = getKFactor(playerGamesPlayed);
  const expectedOutcome = getExpectedOutcome(playerElo, opponentElo);
  const actualOutcome = didWin ? 1 : 0;
  return Math.round(kFactor * (actualOutcome - expectedOutcome));
}

// Calculate battle scores using sophisticated chat analysis
function calculateBattleScores(attacker: Character, defender: Character): {
  attackerScore: number;
  defenderScore: number;
  winnerId: string;
  attackerAnalysis: BattleChatAnalysis;
  defenderAnalysis: BattleChatAnalysis;
} {
  const attackerRating = attacker.rating || attacker.eloScore || DEFAULT_ELO;
  const defenderRating = defender.rating || defender.eloScore || DEFAULT_ELO;
  const eloDiff = attackerRating - defenderRating;
  
  // Analyze both characters' battle chats
  const attackerAnalysis = analyzeBattleChat(attacker);
  const defenderAnalysis = analyzeBattleChat(defender);
  
  // Base scores from chat analysis (70% weight)
  let attackerScore = attackerAnalysis.totalScore * 70;
  let defenderScore = defenderAnalysis.totalScore * 70;
  
  // Apply ELO difference modifier (20% weight)
  const eloModifier = eloDiff * 0.05; // Reduced from 0.1 to give chat more importance
  attackerScore += eloModifier * 20;
  defenderScore -= eloModifier * 20;
  
  // Add controlled randomness (10% weight)
  attackerScore += Math.random() * 10;
  defenderScore += Math.random() * 10;
  
  // Special bonuses for excellence in specific areas
  // If a character excels (8+ score) in any category, give bonus
  const attackerExcellence = Object.values(attackerAnalysis).filter(v => v >= 8).length;
  const defenderExcellence = Object.values(defenderAnalysis).filter(v => v >= 8).length;
  
  attackerScore += attackerExcellence * 5;
  defenderScore += defenderExcellence * 5;
  
  // Ensure minimum scores
  attackerScore = Math.max(attackerScore, 10);
  defenderScore = Math.max(defenderScore, 10);
  
  const winnerId = attackerScore > defenderScore ? attacker.id : defender.id;
  
  return {
    attackerScore: Math.round(attackerScore),
    defenderScore: Math.round(defenderScore),
    winnerId,
    attackerAnalysis,
    defenderAnalysis
  };
}

// Enhanced battle chat analysis with multiple sophisticated criteria
interface BattleChatAnalysis {
  creativity: number;      // Ï∞ΩÏùòÏÑ± - unique word usage, original metaphors
  impact: number;         // ÏûÑÌå©Ìä∏ - powerful opening/closing, memorable phrases
  focus: number;          // ÏßëÏ§ëÎ†• - consistency, coherent narrative
  linguisticPower: number; // Ïñ∏Ïñ¥Ï†ÅÌååÏõå - strong verbs, vivid descriptions
  strategy: number;       // Ï†ÑÎûµÏÑ± - mentions of attack/defense tactics
  emotionMomentum: number; // Í∞êÏ†ïÍ≥º Í∏∞ÏÑ∏ - emotional intensity, confidence
  lengthScore: number;    // Ï±óÏùò Í∏∏Ïù¥ - adequate length for expression
  totalScore: number;     // Overall score
}

// Analyze battle chat for sophisticated scoring
function analyzeBattleChat(character: Character): BattleChatAnalysis {
  const chat = character.battleChat || "";
  const name = character.name;
  const words = chat.split(/\s+/);
  const chatLength = chat.length;
  
  // 1. Ï∞ΩÏùòÏÑ± (Creativity) - Unique word usage, original metaphors
  let creativity = 5;
  const uniqueCharacters = new Set(chat).size;
  const uniquenessRatio = uniqueCharacters / chat.length;
  
  // Special characters and emojis add creativity
  if (/[~‚ô™‚òÖ‚òÜ‚ô°‚ô•‚ú®üî•‚ö°Ô∏èüíÄüëëüó°Ô∏è‚öîÔ∏èüõ°Ô∏èüé≠]/.test(chat)) creativity += 2;
  
  // Unique expressions and metaphors
  const creativePatterns = [
    /\S+Ïùò\s+\S+/,  // "XÏùò Y" pattern (e.g., "Ïñ¥Îë†Ïùò ÏßÄÎ∞∞Ïûê")
    /\S+[ÏúºÎ°ú|Î°ú]\s+\S+/,  // Instrumental patterns
    /ÎßàÏπò\s+\S+Ï≤òÎüº/,  // Similes
    /\S+[Ïù¥|Í∞Ä]\s+\S+[ÌïòÎã§|ÎêòÎã§]/  // Complex verb patterns
  ];
  creativePatterns.forEach(pattern => {
    if (pattern.test(chat)) creativity += 0.5;
  });
  
  // Rare/unique words
  const rareWords = ["Ïö¥Î™Ö", "ÏòÅÌòº", "Ï∞®Ïõê", "ÏãúÍ≥µÍ∞Ñ", "ÏòÅÏõê", "Î¨¥Ìïú", "Ï¥àÏõî", "Í∞ÅÏÑ±", "Î¥âÏù∏", "Ïã¨Ìåê"];
  rareWords.forEach(word => {
    if (chat.includes(word)) creativity += 0.3;
  });
  
  // 2. ÏûÑÌå©Ìä∏ (Impact) - Powerful opening/closing, memorable phrases
  let impact = 5;
  
  // Strong opening
  if (/^[Í∞Ä-Ìû£]+[!?]+/.test(chat)) impact += 1;  // Starts with exclamation
  if (/^[Ïñ¥Îë†|Îπõ|Ïö¥Î™Ö|ÏãúÍ∞Ñ|Ï£ΩÏùå|ÌååÎ©∏]/.test(chat)) impact += 0.5;  // Dramatic opening
  
  // Strong closing
  if (/[!?]{2,}$/.test(chat)) impact += 1;  // Multiple punctuation at end
  if (/[Í∞ÅÏò§|Ï§ÄÎπÑ|Ïö¥Î™Ö|Ïã¨Ìåê|ÎÅù][ÌïòÎã§|ÎêòÎã§|Ïù¥Îã§]*[!?]*$/.test(chat)) impact += 0.5;
  
  // Memorable phrases
  const impactfulPhrases = [
    "Ï†àÎåÄ", "ÏòÅÏõêÌûà", "Í≤∞ÏΩî", "Î∞òÎìúÏãú", "ÎÅùÏóÜÎäî", "Î¨¥ÌïúÌïú", "ÏµúÍ∞ïÏùò", "Ï†ÑÏÑ§Ïùò",
    "Ïö¥Î™Ö", "Ïã¨Ìåê", "ÌååÎ©∏", "Î©∏Îßù", "Í∞ÅÏÑ±", "Ï¥àÏõî"
  ];
  impactfulPhrases.forEach(phrase => {
    if (chat.includes(phrase)) impact += 0.3;
  });
  
  // 3. ÏßëÏ§ëÎ†• (Focus) - Consistency, coherent narrative
  let focus = 5;
  
  // Coherent theme throughout
  const themeWords = {
    magic: ["ÎßàÎ≤ï", "Ï£ºÎ¨∏", "ÎßàÎÇò", "ÏõêÏÜå", "Ï†ïÎ†π"],
    warrior: ["Í≤Ä", "Ïπº", "Ï†ÑÌà¨", "Ï†ÑÏÇ¨", "Î¨¥Í∏∞"],
    dark: ["Ïñ¥Îë†", "Í∑∏Î¶ºÏûê", "ÏïîÌùë", "Ïã¨Ïó∞", "ÏïÖ"],
    light: ["Îπõ", "ÏÑ±Ïä§Îü¨Ïö¥", "Ïã†ÏÑ±Ìïú", "Ï∂ïÎ≥µ", "Ï†ïÏùò"],
    nature: ["ÏûêÏó∞", "Î∞îÎûå", "Î∂à", "Î¨º", "ÎåÄÏßÄ"]
  };
  
  let dominantTheme = 0;
  Object.values(themeWords).forEach(wordSet => {
    const themeCount = wordSet.filter(word => chat.includes(word)).length;
    if (themeCount > dominantTheme) dominantTheme = themeCount;
  });
  focus += Math.min(dominantTheme, 2);
  
  // Clear intent and structure
  if (words.length >= 5 && words.length <= 20) focus += 1;  // Good word count
  if (/[.!?]\s+[Í∞Ä-Ìû£]/.test(chat)) focus += 0.5;  // Multiple sentences
  
  // 4. Ïñ∏Ïñ¥Ï†ÅÌååÏõå (Linguistic Power) - Strong verbs, vivid descriptions
  let linguisticPower = 5;
  
  // Strong action verbs
  const strongVerbs = [
    "ÌååÍ¥¥ÌïòÎã§", "Î∂ÑÏáÑÌïòÎã§", "Î∞ïÏÇ¥ÎÇ¥Îã§", "ÏßìÎ∞üÎã§", "Ï†úÏïïÌïòÎã§", "ÏßÄÎ∞∞ÌïòÎã§",
    "Íµ¥Î≥µÏãúÌÇ§Îã§", "Î¥âÏù∏ÌïòÎã§", "Ìï¥Î∞©ÌïòÎã§", "Í∞ÅÏÑ±ÌïòÎã§", "Ï¥àÏõîÌïòÎã§", "Íµ∞Î¶ºÌïòÎã§"
  ];
  strongVerbs.forEach(verb => {
    if (chat.includes(verb.replace("ÌïòÎã§", ""))) linguisticPower += 0.4;
  });
  
  // Vivid adjectives
  const vividAdjectives = [
    "ÏïïÎèÑÏ†ÅÏù∏", "Ï†àÎåÄÏ†ÅÏù∏", "Î¨¥ÌïúÌïú", "ÏòÅÏõêÌïú", "Ïã†ÏÑ±Ìïú", "Ï†ÄÏ£ºÎ∞õÏùÄ",
    "Î∂àÎ©∏Ïùò", "Ï†ÑÏÑ§Ï†ÅÏù∏", "Ï¥àÏõîÏ†ÅÏù∏", "Í∂ÅÍ∑πÏùò"
  ];
  vividAdjectives.forEach(adj => {
    if (chat.includes(adj.replace("Ïù∏", "").replace("Ïùò", ""))) linguisticPower += 0.3;
  });
  
  // 5. Ï†ÑÎûµÏÑ± (Strategy) - Mentions of attack/defense tactics
  let strategy = 5;
  
  // Attack mentions
  const attackWords = ["Í≥µÍ≤©", "ÌÉÄÍ≤©", "ÏùºÍ≤©", "Í∞ïÌÉÄ", "Ïó∞ÌÉÄ", "ÏΩ§Î≥¥", "ÌïÑÏÇ¥Í∏∞"];
  attackWords.forEach(word => {
    if (chat.includes(word)) strategy += 0.5;
  });
  
  // Defense mentions
  const defenseWords = ["Î∞©Ïñ¥", "ÏàòÎπÑ", "Î≥¥Ìò∏", "Î∞©Ìå®", "ÎßâÎã§", "Î≤ÑÌã∞Îã§", "Í≤¨ÎîîÎã§"];
  defenseWords.forEach(word => {
    if (chat.includes(word)) strategy += 0.5;
  });
  
  // Tactical expressions
  if (/[Ï§ÄÎπÑ|ÎåÄÎπÑ|Í∞ÅÏò§]/.test(chat)) strategy += 0.5;
  if (/[ÏïΩÏ†ê|Í∏âÏÜå|ÎπàÌãà]/.test(chat)) strategy += 0.5;
  
  // 6. Í∞êÏ†ïÍ≥º Í∏∞ÏÑ∏ (Emotion & Momentum) - Emotional intensity, confidence
  let emotionMomentum = 5;
  
  // Confidence indicators
  if (chat.includes("!")) emotionMomentum += 0.5;
  if (chat.includes("!!") || chat.includes("!!!")) emotionMomentum += 1;
  if (/[„Öã„Öé„Ö†„Öú]/.test(chat)) emotionMomentum += 0.5;  // Korean emotion characters
  
  // Emotional words
  const emotionWords = [
    "Î∂ÑÎÖ∏", "Í≤©ÎÖ∏", "ÌôòÌù¨", "Ï†àÎßù", "Í≥µÌè¨", "ÎëêÎ†§ÏõÄ", "Í∏∞ÏÅ®", "Ïä¨Ìîî",
    "Ï¶ùÏò§", "ÏÇ¨Îûë", "Ïó¥Ï†ï", "Ìà¨ÏßÄ", "ÏùòÏßÄ", "Í≤∞Ïùò"
  ];
  emotionWords.forEach(word => {
    if (chat.includes(word)) emotionMomentum += 0.4;
  });
  
  // Battle cries and exclamations
  const battleCries = ["ÌùêÌïòÌïò", "ÌÅ¨ÌïòÌïò", "ÌõÑÌõÑ", "ÌùêÌùê", "ÏºÄÏºÄ", "ÏùåÌïòÌïò", "Ïö∞ÌïòÌïò", "ÏïÑÌïòÌïò"];
  battleCries.forEach(cry => {
    if (chat.includes(cry)) emotionMomentum += 0.5;
  });
  
  // 7. Ï±óÏùò Í∏∏Ïù¥ (Chat Length) - Adequate length for expression
  let lengthScore = 5;
  
  if (chatLength < 10) {
    lengthScore = 3;  // Too short
  } else if (chatLength >= 10 && chatLength < 30) {
    lengthScore = 6;  // A bit short but acceptable
  } else if (chatLength >= 30 && chatLength <= 100) {
    lengthScore = 10;  // Perfect length
  } else if (chatLength > 100 && chatLength <= 150) {
    lengthScore = 8;  // Good but a bit long
  } else {
    lengthScore = 6;  // Too long
  }
  
  // Normalize all scores to 0-10 range
  creativity = Math.min(Math.max(creativity, 0), 10);
  impact = Math.min(Math.max(impact, 0), 10);
  focus = Math.min(Math.max(focus, 0), 10);
  linguisticPower = Math.min(Math.max(linguisticPower, 0), 10);
  strategy = Math.min(Math.max(strategy, 0), 10);
  emotionMomentum = Math.min(Math.max(emotionMomentum, 0), 10);
  lengthScore = Math.min(Math.max(lengthScore, 0), 10);
  
  // Calculate total score with weights
  const totalScore = (
    creativity * 0.15 +
    impact * 0.15 +
    focus * 0.15 +
    linguisticPower * 0.15 +
    strategy * 0.15 +
    emotionMomentum * 0.15 +
    lengthScore * 0.10
  );
  
  return {
    creativity: Math.round(creativity * 10) / 10,
    impact: Math.round(impact * 10) / 10,
    focus: Math.round(focus * 10) / 10,
    linguisticPower: Math.round(linguisticPower * 10) / 10,
    strategy: Math.round(strategy * 10) / 10,
    emotionMomentum: Math.round(emotionMomentum * 10) / 10,
    lengthScore: Math.round(lengthScore * 10) / 10,
    totalScore: Math.round(totalScore * 10) / 10
  };
}

// Generate detailed battle analysis with scoring breakdown
function generateBattleAnalysis(
  attacker: Character,
  defender: Character,
  attackerScore: number,
  defenderScore: number,
  winnerId: string,
  attackerAnalysis: BattleChatAnalysis,
  defenderAnalysis: BattleChatAnalysis
): { summary: string; explanation?: string; tip?: string; scoreBreakdown?: string } {
  const winner = winnerId === attacker.id ? attacker : defender;
  const loser = winnerId === attacker.id ? defender : attacker;
  const winnerAnalysis = winnerId === attacker.id ? attackerAnalysis : defenderAnalysis;
  const loserAnalysis = winnerId === attacker.id ? defenderAnalysis : attackerAnalysis;
  
  // Find the strongest factors for the winner
  const winnerStrengths: string[] = [];
  const scoreComparisons = [
    { name: "Ï∞ΩÏùòÏÑ±", winScore: winnerAnalysis.creativity, loseScore: loserAnalysis.creativity },
    { name: "ÏûÑÌå©Ìä∏", winScore: winnerAnalysis.impact, loseScore: loserAnalysis.impact },
    { name: "ÏßëÏ§ëÎ†•", winScore: winnerAnalysis.focus, loseScore: loserAnalysis.focus },
    { name: "Ïñ∏Ïñ¥Ï†Å ÌååÏõå", winScore: winnerAnalysis.linguisticPower, loseScore: loserAnalysis.linguisticPower },
    { name: "Ï†ÑÎûµÏÑ±", winScore: winnerAnalysis.strategy, loseScore: loserAnalysis.strategy },
    { name: "Í∞êÏ†ïÍ≥º Í∏∞ÏÑ∏", winScore: winnerAnalysis.emotionMomentum, loseScore: loserAnalysis.emotionMomentum },
    { name: "Ï±óÏùò Í∏∏Ïù¥", winScore: winnerAnalysis.lengthScore, loseScore: loserAnalysis.lengthScore }
  ];
  
  // Sort by winner's advantage
  scoreComparisons.sort((a, b) => (b.winScore - b.loseScore) - (a.winScore - a.loseScore));
  
  // Take top 3 advantages
  const topAdvantages = scoreComparisons.slice(0, 3).filter(comp => comp.winScore > comp.loseScore);
  topAdvantages.forEach(adv => {
    winnerStrengths.push(`${adv.name} (${adv.winScore}/10)`);
  });
  
  // Generate the summary
  let summary = `${winner.name}Ïùò ÏäπÎ¶¨! `;
  
  if (winnerStrengths.length > 0) {
    summary += `${winner.name}ÏùÄ(Îäî) ${winnerStrengths.join(", ")}ÏóêÏÑú Ïö∞ÏúÑÎ•º Ï†êÌñàÏäµÎãàÎã§. `;
  }
  
  const scoreDiff = Math.abs(attackerScore - defenderScore);
  if (scoreDiff < 20) {
    summary += "ÏïÑÏ£º ÏπòÏó¥Ìïú Ï†ëÏ†ÑÏù¥ÏóàÏäµÎãàÎã§!";
  } else if (scoreDiff < 50) {
    summary += "Î™ÖÌôïÌïú Ïã§Î†• Ï∞®Ïù¥Î•º Î≥¥Ïó¨Ï£ºÏóàÏäµÎãàÎã§.";
  } else {
    summary += "ÏïïÎèÑÏ†ÅÏù∏ ÏäπÎ¶¨ÏòÄÏäµÎãàÎã§!";
  }
  
  // Generate detailed score breakdown
  let scoreBreakdown = `\n\nüìä Ï†ÑÌà¨ Ï†êÏàò Î∂ÑÏÑù:\n`;
  scoreBreakdown += `${attacker.name}:\n`;
  scoreBreakdown += `‚Ä¢ Ï∞ΩÏùòÏÑ±: ${attackerAnalysis.creativity}/10\n`;
  scoreBreakdown += `‚Ä¢ ÏûÑÌå©Ìä∏: ${attackerAnalysis.impact}/10\n`;
  scoreBreakdown += `‚Ä¢ ÏßëÏ§ëÎ†•: ${attackerAnalysis.focus}/10\n`;
  scoreBreakdown += `‚Ä¢ Ïñ∏Ïñ¥Ï†Å ÌååÏõå: ${attackerAnalysis.linguisticPower}/10\n`;
  scoreBreakdown += `‚Ä¢ Ï†ÑÎûµÏÑ±: ${attackerAnalysis.strategy}/10\n`;
  scoreBreakdown += `‚Ä¢ Í∞êÏ†ïÍ≥º Í∏∞ÏÑ∏: ${attackerAnalysis.emotionMomentum}/10\n`;
  scoreBreakdown += `‚Ä¢ Ï±óÏùò Í∏∏Ïù¥: ${attackerAnalysis.lengthScore}/10\n`;
  scoreBreakdown += `‚Ä¢ Ï¢ÖÌï© Ï†êÏàò: ${attackerAnalysis.totalScore}/10\n\n`;
  
  scoreBreakdown += `${defender.name}:\n`;
  scoreBreakdown += `‚Ä¢ Ï∞ΩÏùòÏÑ±: ${defenderAnalysis.creativity}/10\n`;
  scoreBreakdown += `‚Ä¢ ÏûÑÌå©Ìä∏: ${defenderAnalysis.impact}/10\n`;
  scoreBreakdown += `‚Ä¢ ÏßëÏ§ëÎ†•: ${defenderAnalysis.focus}/10\n`;
  scoreBreakdown += `‚Ä¢ Ïñ∏Ïñ¥Ï†Å ÌååÏõå: ${defenderAnalysis.linguisticPower}/10\n`;
  scoreBreakdown += `‚Ä¢ Ï†ÑÎûµÏÑ±: ${defenderAnalysis.strategy}/10\n`;
  scoreBreakdown += `‚Ä¢ Í∞êÏ†ïÍ≥º Í∏∞ÏÑ∏: ${defenderAnalysis.emotionMomentum}/10\n`;
  scoreBreakdown += `‚Ä¢ Ï±óÏùò Í∏∏Ïù¥: ${defenderAnalysis.lengthScore}/10\n`;
  scoreBreakdown += `‚Ä¢ Ï¢ÖÌï© Ï†êÏàò: ${defenderAnalysis.totalScore}/10`;
  
  // Generate explanation and tip
  let explanation: string | undefined;
  let tip: string | undefined;
  
  // Always provide explanation for better understanding
  if (scoreDiff > 30) {
    const excellentScores = Object.entries({
      creativity: { score: winnerAnalysis.creativity, name: "Ï∞ΩÏùòÏÑ±", tip: "ÌäπÏàòÎ¨∏Ïûê, ÏùÄÏú†, ÎèÖÌäπÌïú ÌëúÌòÑÏùÑ ÏÇ¨Ïö©ÌïòÎ©¥ Ï∞ΩÏùòÏÑ±Ïù¥ ÎÜíÏïÑÏßëÎãàÎã§." },
      impact: { score: winnerAnalysis.impact, name: "ÏûÑÌå©Ìä∏", tip: "Í∞ïÎ†¨Ìïú ÏãúÏûëÍ≥º ÎÅù, Í∏∞ÏñµÏóê ÎÇ®Îäî Î¨∏Íµ¨Î•º ÏÇ¨Ïö©ÌïòÏÑ∏Ïöî." },
      linguisticPower: { score: winnerAnalysis.linguisticPower, name: "Ïñ∏Ïñ¥Ï†Å ÌååÏõå", tip: "Í∞ïÎ†•Ìïú ÎèôÏÇ¨ÏôÄ ÏÉùÏÉùÌïú ÌòïÏö©ÏÇ¨Î•º ÌôúÏö©ÌïòÏÑ∏Ïöî." },
      emotionMomentum: { score: winnerAnalysis.emotionMomentum, name: "Í∞êÏ†ïÍ≥º Í∏∞ÏÑ∏", tip: "Í∞êÏ†ïÏùÑ Îã¥ÏùÄ ÌëúÌòÑÍ≥º ÏûêÏã†Í∞ê ÏûàÎäî Ïñ¥Ï°∞Î•º ÏÇ¨Ïö©ÌïòÏÑ∏Ïöî." }
    });
    
    const bestCategory = Object.entries(excellentScores)
      .sort((a, b) => b[1].score - a[1].score)[0];
    
    if (bestCategory && bestCategory[1].score > 8) {
      explanation = `Îõ∞Ïñ¥ÎÇú ${bestCategory[1].name}(${bestCategory[1].score}/10)Ïù¥(Í∞Ä) ÏäπÎ¶¨Ïùò Í≤∞Ï†ïÏ†Å ÏöîÏù∏Ïù¥ÏóàÏäµÎãàÎã§!`;
      tip = bestCategory[1].tip;
    } else {
      explanation = "Ï†ÑÎ∞òÏ†ÅÏúºÎ°ú Í∑†ÌòïÏû°Ìûå Ïö∞ÏàòÌïú Ï†ÑÌà¨ ÎåÄÏÇ¨Î°ú ÏôÑÏäπÏùÑ Í±∞ÎëêÏóàÏäµÎãàÎã§!";
      tip = "Î™®Îì† ÌèâÍ∞Ä ÏöîÏÜåÎ•º Í≥®Í≥†Î£® Ïã†Í≤ΩÏì∞Î©¥ ÏïàÏ†ïÏ†ÅÏù∏ ÏäπÎ•†ÏùÑ Ïú†ÏßÄÌï† Ïàò ÏûàÏäµÎãàÎã§.";
    }
  } else if (scoreDiff > 15) {
    // Find the biggest difference
    const biggestDiff = scoreComparisons[0];
    explanation = `${biggestDiff.name}ÏóêÏÑúÏùò Ïö∞ÏúÑ(${biggestDiff.winScore} vs ${biggestDiff.loseScore})Í∞Ä ÏäπÎ∂ÄÎ•º Í≤∞Ï†ïÏßÄÏóàÏäµÎãàÎã§.`;
    
    const categoryTips = {
      "Ï∞ΩÏùòÏÑ±": "ÎèÖÌäπÌïú Îã®Ïñ¥ÏôÄ ÌëúÌòÑÏùÑ ÏÇ¨Ïö©Ìï¥ Ï∞ΩÏùòÏÑ±ÏùÑ ÎÜíÏù¥ÏÑ∏Ïöî.",
      "ÏûÑÌå©Ìä∏": "Í∞ïÎ†¨Ìïú ÏãúÏûëÍ≥º ÎßàÎ¨¥Î¶¨Î°ú ÏûÑÌå©Ìä∏Î•º ÎÜíÏù¥ÏÑ∏Ïöî.",
      "ÏßëÏ§ëÎ†•": "ÏùºÍ¥ÄÎêú Ï£ºÏ†úÏôÄ Î™ÖÌôïÌïú ÏùòÎèÑÎ°ú ÏßëÏ§ëÎ†•ÏùÑ Î≥¥Ïó¨Ï£ºÏÑ∏Ïöî.",
      "Ïñ∏Ïñ¥Ï†Å ÌååÏõå": "Í∞ïÎ†•Ìïú ÎèôÏÇ¨ÏôÄ ÏÉùÏÉùÌïú ÌëúÌòÑÏùÑ ÏÇ¨Ïö©ÌïòÏÑ∏Ïöî.",
      "Ï†ÑÎûµÏÑ±": "Í≥µÍ≤©Í≥º Î∞©Ïñ¥ Ï†ÑÏà†ÏùÑ Ïñ∏Í∏âÌï¥ Ï†ÑÎûµÏÑ±ÏùÑ ÎìúÎü¨ÎÇ¥ÏÑ∏Ïöî.",
      "Í∞êÏ†ïÍ≥º Í∏∞ÏÑ∏": "Í∞êÏ†ïÏùÑ Îã¥Í≥† ÏûêÏã†Í∞ê ÏûàÍ≤å ÌëúÌòÑÌïòÏÑ∏Ïöî.",
      "Ï±óÏùò Í∏∏Ïù¥": "30-100Ïûê ÏÇ¨Ïù¥Ïùò Ï†ÅÏ†àÌïú Í∏∏Ïù¥Î•º Ïú†ÏßÄÌïòÏÑ∏Ïöî."
    };
    tip = categoryTips[biggestDiff.name] || "Î™®Îì† ÏöîÏÜåÎ•º Í∑†ÌòïÏûàÍ≤å Î∞úÏ†ÑÏãúÌÇ§ÏÑ∏Ïöî.";
  } else {
    explanation = "ÏïÑÏä¨ÏïÑÏä¨Ìïú ÏäπÎ∂Ä! ÏûëÏùÄ Ï∞®Ïù¥Í∞Ä ÏäπÌå®Î•º Í∞àÎûêÏäµÎãàÎã§.";
    tip = "Í∑ºÏÜåÌïú Ï∞®Ïù¥Î°ú ÏäπÎ∂ÄÍ∞Ä Í≤∞Ï†ïÎêòÏóàÏäµÎãàÎã§. Ï°∞Í∏àÎßå Îçî Ïó∞ÏäµÌïòÎ©¥ Ïó≠Ï†ÑÌï† Ïàò ÏûàÏäµÎãàÎã§!";
  }
  
  return { summary, explanation, tip, scoreBreakdown };
}

// Generate battle log (simplified)
function generateBattleLog(
  attacker: Character,
  defender: Character,
  attackerScore: number,
  defenderScore: number,
  winnerId: string
): string[] {
  // Return the analysis summary as a single string in an array
  const analysis = generateBattleAnalysis(attacker, defender, attackerScore, defenderScore, winnerId);
  return [analysis.summary];
}

// Check if a user can battle
export async function checkBattleRestrictions(
  userId: string,
  attackerId: string,
  defenderId: string,
  isAttacking: boolean = true
): Promise<{ canBattle: boolean; error?: string }> {
  try {
    const now = new Date();
    const restriction = battleRestrictions.get(userId);
    
    if (restriction) {
      // Check cooldown
      const timeSinceLastBattle = now.getTime() - restriction.lastBattleTime.getTime();
      if (timeSinceLastBattle < BATTLE_COOLDOWN_MS) {
        const remainingTime = Math.ceil((BATTLE_COOLDOWN_MS - timeSinceLastBattle) / 1000);
        return {
          canBattle: false,
          error: `Please wait ${remainingTime} seconds before battling again`
        };
      }
      
      // Check daily limit (reset at midnight)
      const lastBattleDate = restriction.lastBattleTime.toDateString();
      const currentDate = now.toDateString();
      
      if (lastBattleDate === currentDate && restriction.dailyBattleCount >= DAILY_BATTLE_LIMIT) {
        return {
          canBattle: false,
          error: `Daily battle limit (${DAILY_BATTLE_LIMIT}) reached. Try again tomorrow!`
        };
      }
    }
    
    return { canBattle: true };
  } catch (error: any) {
    console.error("Error checking battle restrictions:", error);
    return { canBattle: false, error: error.message };
  }
}

// Update battle restrictions after a battle
export async function updateBattleRestrictions(userId: string): Promise<void> {
  const now = new Date();
  const restriction = battleRestrictions.get(userId);
  
  if (restriction) {
    const lastBattleDate = restriction.lastBattleTime.toDateString();
    const currentDate = now.toDateString();
    
    if (lastBattleDate === currentDate) {
      // Same day, increment count
      restriction.dailyBattleCount++;
    } else {
      // New day, reset count
      restriction.dailyBattleCount = 1;
    }
    restriction.lastBattleTime = now;
  } else {
    // First battle
    battleRestrictions.set(userId, {
      lastBattleTime: now,
      dailyBattleCount: 1
    });
  }
}

// Create a new battle
export async function createBattle(
  attackerId: string,
  defenderId: string
): Promise<{ data: any; error: string | null }> {
  try {
    // Get both characters
    const attacker = characters.get(attackerId);
    const defender = characters.get(defenderId);
    
    if (!attacker || !defender) {
      return { data: null, error: "Character not found" };
    }
    
    // Calculate battle outcome with detailed analysis
    const { 
      attackerScore, 
      defenderScore, 
      winnerId,
      attackerAnalysis,
      defenderAnalysis
    } = calculateBattleScores(attacker, defender);
    
    // Calculate ELO changes
    const attackerWon = winnerId === attackerId;
    const attackerGamesPlayed = attacker.wins + attacker.losses;
    const defenderGamesPlayed = defender.wins + defender.losses;
    
    const attackerRating = attacker.rating || attacker.eloScore || DEFAULT_ELO;
    const defenderRating = defender.rating || defender.eloScore || DEFAULT_ELO;
    
    const attackerEloChange = calculateEloChange(
      attackerRating,
      defenderRating,
      attackerWon,
      attackerGamesPlayed
    );
    
    const defenderEloChange = calculateEloChange(
      defenderRating,
      attackerRating,
      !attackerWon,
      defenderGamesPlayed
    );
    
    // Generate battle analysis with explanation
    const analysis = generateBattleAnalysis(
      attacker,
      defender,
      attackerScore,
      defenderScore,
      winnerId,
      attackerAnalysis,
      defenderAnalysis
    );
    
    // Generate battle log with score breakdown
    const battleLog = [analysis.summary];
    if (analysis.scoreBreakdown) {
      battleLog.push(analysis.scoreBreakdown);
    }
    
    // Create battle record
    const battleId = `battle_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const battle: Battle = {
      id: battleId,
      player1Id: attackerId,
      player2Id: defenderId,
      winnerId,
      player1EloChange: attackerEloChange,
      player2EloChange: defenderEloChange,
      createdAt: new Date()
    };
    
    battles.set(battleId, battle);
    
    // Update characters
    if (attackerWon) {
      attacker.wins++;
      defender.losses++;
    } else {
      attacker.losses++;
      defender.wins++;
    }
    
    // Update total battles count
    attacker.totalBattles = (attacker.totalBattles || 0) + 1;
    defender.totalBattles = (defender.totalBattles || 0) + 1;
    
    // Update ratings
    if (attacker.rating !== undefined) {
      attacker.rating += attackerEloChange;
    } else {
      attacker.eloScore = (attacker.eloScore || DEFAULT_ELO) + attackerEloChange;
    }
    
    if (defender.rating !== undefined) {
      defender.rating += defenderEloChange;
    } else {
      defender.eloScore = (defender.eloScore || DEFAULT_ELO) + defenderEloChange;
    }
    
    attacker.updatedAt = new Date();
    defender.updatedAt = new Date();
    
    // Save updated characters back to memory store
    characters.set(attackerId, attacker);
    characters.set(defenderId, defender);
    
    // Update battle restrictions for non-NPC attacker
    if (!attacker.isNPC) {
      await updateBattleRestrictions(attacker.userId);
    }
    
    // Check if we should include detailed analysis (every 7 battles)
    const attackerBattleCount = attacker.totalBattles || 0;
    const shouldShowDetailedAnalysis = attackerBattleCount % 7 === 0;
    
    // Return battle result with detailed analysis conditionally
    const result = {
      id: battleId,
      attackerId,
      defenderId,
      winnerId,
      attackerScore,
      defenderScore,
      battleLog,
      explanation: analysis.explanation,  // Always show brief explanation
      tip: analysis.tip,  // Always show tip
      attackerEloChange,
      defenderEloChange,
      createdAt: battle.createdAt,
      // Include detailed scoring breakdown only every 10 battles
      ...(shouldShowDetailedAnalysis && {
        attackerAnalysis,
        defenderAnalysis
      })
    };
    
    return { data: result, error: null };
  } catch (error: any) {
    console.error("Error creating battle:", error);
    return { data: null, error: error.message };
  }
}

// Get recent battles for a character
export async function getRecentBattles(
  characterId: string,
  limit = 10
): Promise<{ data: any[]; error: string | null }> {
  try {
    const recentBattles = Array.from(battles.values())
      .filter(battle => 
        battle.player1Id === characterId || battle.player2Id === characterId
      )
      .sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime())
      .slice(0, limit)
      .map(battle => {
        const isPlayer1 = battle.player1Id === characterId;
        const opponentId = isPlayer1 ? battle.player2Id : battle.player1Id;
        const opponent = characters.get(opponentId);
        const didWin = battle.winnerId === characterId;
        const eloChange = isPlayer1 ? battle.player1EloChange : battle.player2EloChange;
        
        return {
          id: battle.id,
          opponentName: opponent?.name || "Unknown",
          didWin,
          eloChange,
          createdAt: battle.createdAt
        };
      });
    
    return { data: recentBattles, error: null };
  } catch (error: any) {
    console.error("Error fetching recent battles:", error);
    return { data: [], error: error.message };
  }
}

// Note: getCharacterById is imported from character-server.ts

// Get user battle statistics
export async function getUserBattleStats(userId: string) {
  try {
    const now = new Date();
    const restriction = battleRestrictions.get(userId);
    
    let dailyBattlesUsed = 0;
    let canBattleToday = true;
    
    if (restriction) {
      const lastBattleDate = restriction.lastBattleTime.toDateString();
      const currentDate = now.toDateString();
      
      if (lastBattleDate === currentDate) {
        dailyBattlesUsed = restriction.dailyBattleCount;
        canBattleToday = dailyBattlesUsed < DAILY_BATTLE_LIMIT;
      }
    }
    
    const stats = {
      dailyBattlesUsed,
      dailyBattlesRemaining: DAILY_BATTLE_LIMIT - dailyBattlesUsed,
      canBattleToday,
      dailyLimit: DAILY_BATTLE_LIMIT,
      cooldownMs: BATTLE_COOLDOWN_MS
    };
    
    return { data: stats, error: null };
  } catch (error: any) {
    console.error("Error getting user battle stats:", error);
    return { data: null, error: error.message };
  }
}